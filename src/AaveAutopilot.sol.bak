// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0 || ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";
import "@openzeppelin/contracts/access/Ownable2Step.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "./interfaces/IAave.sol";
import "./interfaces/AggregatorV3Interface.sol";
import "./interfaces/KeeperCompatibleInterface.sol";

/**
 * @title AaveAutopilot
 * @notice ERC-4626 vault that manages Aave v3 positions with automatic health factor monitoring
 * @dev Implements intelligent position management to prevent liquidations
 */
/// @title AaveAutopilot
/// @notice ERC-4626 vault with automated Aave v3 position management and Chainlink Automation
/// @dev Implements reentrancy protection, pausable functionality, and access control
contract AaveAutopilot is 
    ERC4626, 
    Ownable2Step, 
    ReentrancyGuard, 
    Pausable, 
    AccessControl, 
    KeeperCompatibleInterface 
{
    using SafeERC20 for IERC20;
    
    // Roles
    bytes32 public constant KEEPER_ROLE = keccak256("KEEPER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    // ============ State Variables ============

    /// @notice Minimum health factor before triggering auto-adjustment (1.05x)
    uint256 public constant MIN_HEALTH_FACTOR = 1.05e18;

    /// @notice Target health factor after rebalancing (1.5x)
    uint256 public constant TARGET_HEALTH_FACTOR = 1.5e18;

    /// @notice Health factor threshold for Keeper check (1.1x)
    uint256 public constant KEEPER_THRESHOLD = 1.1e18;
    
    /// @notice Maximum slippage for repayments (1%)
    uint256 public constant MAX_SLIPPAGE = 1e16; // 1%
    
    /// @notice Minimum time between rebalances (1 hour)
    uint256 public constant REBALANCE_COOLDOWN = 1 hours;
    
    /// @notice Maximum number of rebalance attempts in a single transaction
    uint8 public constant MAX_REBALANCE_ATTEMPTS = 3;

    /// @notice Chainlink ETH/USD price feed
    AggregatorV3Interface public immutable ethUsdPriceFeed;

    /// @notice Aave Pool contract
    IPool public immutable aavePool;
    
    /// @notice Aave Data Provider contract
    IPoolDataProvider public immutable aaveDataProvider;
    
    /// @notice Aave aToken for the underlying asset
    IAToken public immutable aToken;
    
    /// @notice Track last rebalance timestamp per user
    mapping(address => uint256) public lastRebalanceTimestamp;
    
    /// @notice Track rebalance attempt count per user in current transaction
    mapping(address => uint8) private _rebalanceAttempts;

    // ============ Events ============

    event HealthFactorChecked(uint256 healthFactor, bool actionTaken);
    event PositionAdjusted(uint256 oldHealthFactor, uint256 newHealthFactor);
    event PositionRebalanced(address indexed user, uint256 oldHealthFactor, uint256 newHealthFactor);
    event KeeperTriggered(address indexed keeper, address indexed user, uint256 healthFactor);
    event RebalanceAttempt(
        address indexed user,
        uint256 oldHealthFactor,
        uint256 newHealthFactor,
        bool success,
        string reason
    );
    event MaxAttemptsReached(address indexed user);
    
    // ERC4626 Events
    event Deposited(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
    event Withdrawn(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);

    // ============ Constructor ============

    /**
     * @param _asset The underlying asset (e.g., USDC)
     * @param _name Name of the vault token
     * @param _symbol Symbol of the vault token
     * @param _aavePool The Aave v3 pool address
     * @param _aaveDataProvider The Aave v3 data provider address
     * @param _aToken The Aave v3 aToken address
     * @param _ethUsdPriceFeed Chainlink ETH/USD price feed address
     * @param _owner Owner of the contract
     */
    constructor(
        IERC20 _asset,
        string memory _name,
        string memory _symbol,
        address _aavePool,
        address _aaveDataProvider,
        address _aToken,
        address _ethUsdPriceFeed,
        address _owner
    ) ERC4626(_asset) ERC20(_name, _symbol) Ownable(_owner) {
        // Set up roles
        _grantRole(DEFAULT_ADMIN_ROLE, _owner);
        _grantRole(PAUSER_ROLE, _owner);
        _grantRole(KEEPER_ROLE, _owner);
        
        require(_aavePool != address(0), "Invalid Aave Pool");
        require(_aaveDataProvider != address(0), "Invalid Data Provider");
        require(_aToken != address(0), "Invalid aToken");
        require(_ethUsdPriceFeed != address(0), "Invalid Price Feed");
        
        aavePool = IPool(_aavePool);
        aaveDataProvider = IPoolDataProvider(_aaveDataProvider);
        aToken = IAToken(_aToken);
        ethUsdPriceFeed = AggregatorV3Interface(_ethUsdPriceFeed);
        
        // Approve Aave Pool to spend our tokens
        IERC20(asset()).safeIncreaseAllowance(_aavePool, type(uint256).max);
        
        // Transfer ownership to the specified owner
        _transferOwnership(_owner);
    }

    // ============ Core ERC-4626 Functions ============

    /**
     * @notice Total assets managed by the vault
     */
    // Update totalAssets to get real balance from Aave
    function totalAssets() public view override returns (uint256) {
        return aToken.balanceOf(address(this)); // Real-time balance with interest
    }

    /**
     * @notice Deposit assets into the vault
     */
    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) 
        internal 
        override 
        nonReentrant 
        whenNotPaused 
    {
        require(assets > 0, "Cannot deposit 0");
        require(shares > 0, "Invalid share amount");
        
        // First, transfer assets from the caller to this contract
        SafeERC20.safeTransferFrom(IERC20(asset()), caller, address(this), assets);
        
        // Then supply to Aave
        aavePool.supply(asset(), assets, address(this), 0);
        
        // Finally, mint shares to the receiver
        _mint(receiver, shares);
        
        emit Deposit(caller, receiver, assets, shares);
        emit Deposited(caller, receiver, assets, shares);
    }

    /**
     * @notice Withdraw assets from the vault
     */
    // Update _withdraw function
    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256 assets,
        uint256 shares
    ) 
        internal 
        override 
        nonReentrant 
        whenNotPaused 
    {
        require(assets > 0, "Cannot withdraw 0");
        require(shares > 0, "Invalid share amount");
        
        // Check health factor after withdrawal
        uint256 healthFactor = getCurrentHealthFactor();
        require(healthFactor >= MIN_HEALTH_FACTOR, "Withdrawal would make position unsafe");
        
        // Withdraw from Aave
        aavePool.withdraw(asset(), assets, address(this));
        
        super._withdraw(caller, receiver, owner, assets, shares);
        
        emit Withdrawn(caller, receiver, owner, assets, shares);
    }

            // ============ Chainlink Automation ============
    
    // Constants for batch processing and circuit breaker
    uint256 public currentBatchIndex;
    uint256 public constant MAX_REBALANCE_ATTEMPTS = 3;
    
    // Track rebalance attempts per user (resets each transaction)
    mapping(address => uint8) private _rebalanceAttempts;
    
    /**
     * @notice Method called by Chainlink Keepers to check if upkeep is needed
     * @dev Processes users in batches to avoid gas limits
     */
    function checkUpkeep(
        bytes calldata checkData
    ) 
        external 
        view 
        override 
        returns (bool upkeepNeeded, bytes memory performData) 
    {
        // Decode checkData if provided, otherwise use default values
        (uint256 maxUsers, uint256 minHealthFactor) = checkData.length > 0 
            ? abi.decode(checkData, (uint256, uint256))
            : (50, KEEPER_THRESHOLD);
            
        // In a production environment, you would query a list of users from storage
        // For this example, we'll use a simplified approach with a single user
        address[] memory users = new address[](1);
        users[0] = address(this);
        
        // Check health factor for each user
        uint256 healthFactor = getHealthFactor(users[0]);
        upkeepNeeded = healthFactor < minHealthFactor;
        
        // If no users need rebalancing, return early
        if (!upkeepNeeded) {
            return (false, bytes(""));
        }
        
        // Return the list of users that need rebalancing
        return (true, abi.encode(users));
    }
    
    /**
     * @notice Method called by Chainlink Keepers to perform upkeep
     * @dev Will only be called if checkUpkeep returns true
     */
    function performUpkeep(
        bytes calldata performData
    ) 
        external 
        override 
        onlyRole(KEEPER_ROLE) 
        whenNotPaused 
        nonReentrant
    {
        address[] memory users = abi.decode(performData, (address[]));
        uint256 gasLeft = gasleft();
        uint256 gasUsed = 0;
        uint256 gasLimit = block.gaslimit - 100000; // Leave some gas for final operations
        
        for (uint256 i = 0; i < users.length; i++) {
            // Check if we have enough gas left
            if (gasUsed + 100000 > gasLimit) { // Reserve 100k gas per iteration
                break;
            }
            
            address user = users[i];
            uint256 initialGas = gasleft();
            
            // Reset rebalance attempts at the start of each transaction
            if (_rebalanceAttempts[user] == 0) {
                _rebalanceAttempts[user] = 1;
            } else if (_rebalanceAttempts[user] >= MAX_REBALANCE_ATTEMPTS) {
                emit MaxAttemptsReached(user);
                continue;
            } else {
                _rebalanceAttempts[user]++;
            }
            
            // Skip if cooldown not met
            if (block.timestamp < lastRebalanceTimestamp[user] + REBALANCE_COOLDOWN) {
                continue;
            }
            
            // Check health factor
            uint256 healthFactor = getHealthFactor(user);
            if (healthFactor >= KEEPER_THRESHOLD) {
                continue;
            }
            
try this._rebalancePosition(user) {
                // Update last rebalance timestamp on success
                lastRebalanceTimestamp[user] = block.timestamp;
                emit PositionRebalanced(user, healthFactor, getHealthFactor(user));
            } catch Error(string memory reason) {
                emit RebalanceAttempt(user, healthFactor, getHealthFactor(user), false, reason);
            } catch (bytes memory) {
                emit RebalanceAttempt(user, healthFactor, getHealthFactor(user), false, "Unknown error");
            }
            }
        }
        
        // Update batch index for next run (uncomment if batch processing is implemented)
        // currentBatchIndex = (currentBatchIndex + 1) % 10;
    }
    
    // ============ Health Factor Management ============
    
    /**
     * @notice Get the current health factor from Aave
     * @return healthFactor The current health factor (scaled by 1e18)
     */
    function getCurrentHealthFactor() public view returns (uint256 healthFactor) {
        (, , , , , healthFactor) = aaveDataProvider.getUserAccountData(address(this));
        return healthFactor;
    }
    
    /**
     * @notice Get the current health factor for a user
     * @param user The address of the user
     * @return healthFactor The current health factor (scaled by 1e18)
     */
    function getHealthFactor(address user) public view returns (uint256) {
        if (user == address(0)) return 0;
        
        // Get user account data from Aave
        (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        ) = aaveDataProvider.getUserAccountData(user);
        
        return healthFactor;
    }
    
    /**
     * @notice Get the current ETH price in USD from Chainlink
     * @return The ETH price with 8 decimals
     */
    function getEthPrice() public view returns (uint256) {
        (
            , 
            int256 price,
            ,
            ,
            
        ) = ethUsdPriceFeed.latestRoundData();
        require(price > 0, "Invalid price feed");
        return uint256(price);
    }
    
    /**
     * @notice Get the current asset price in ETH
     * @return The asset price with 18 decimals
     * @dev In a production environment, you would use a price oracle like Chainlink
     * For this example, we'll assume the asset is USDC and return a fixed price
     */
    function getAssetPrice() public view returns (uint256) {
        // In a real implementation, you would get the asset price from a price oracle
        // For Base Sepolia, you would use the appropriate Chainlink price feed
        return 1e18; // 1 USDC = 1e18 wei (for testing)
    }
    
    /**
     * @notice Check and adjust the position's health factor
     */
    function checkAndAdjustPosition() external whenNotPaused {
        uint256 healthFactor = getCurrentHealthFactor();
        if (healthFactor < MIN_HEALTH_FACTOR) {
            this._rebalancePosition(msg.sender);
        }
    }
    
    /**
     * @notice Internal function to rebalance the position
     * @param user Address of the user whose position needs rebalancing
     */
    /**
     * @notice Internal function to rebalance a user's position
     * @param user Address of the user to rebalance
     * @dev This function is called by performUpkeep and should not be called directly
     */
    /**
     * @notice Internal function to rebalance a user's position
     * @param user Address of the user to rebalance
     * @dev This function is called by performUpkeep and should not be called directly
     */
    function _rebalancePosition(address user) external {
        require(msg.sender == address(this), "Only callable internally");
        
        uint256 currentHf = getHealthFactor(user);
        require(currentHf < KEEPER_THRESHOLD, "Health factor above threshold");
        
        // Get current position data from Aave
        (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        ) = aaveDataProvider.getUserAccountData(user);
        
        // Calculate the target debt to reach TARGET_HEALTH_FACTOR
        uint256 targetDebtETH = (totalCollateralETH * currentLiquidationThreshold * 1e4) / (TARGET_HEALTH_FACTOR * 1e4 / 1e18);
        
        // If current debt is already below target, no need to rebalance
        if (totalDebtETH <= targetDebtETH) {
            emit PositionAdjusted(currentHf, getHealthFactor(user));
            return;
        }
        
        // Calculate the amount to repay (in ETH terms)
        uint256 repayAmountETH = totalDebtETH - targetDebtETH;
        
        // Get the underlying asset price in ETH
        uint256 ethPrice = getEthPrice();
        uint256 assetPrice = getAssetPrice();
        
        // Convert repay amount from ETH to asset amount (with 18 decimals)
        uint256 repayAmount = (repayAmountETH * 1e18) / assetPrice;
        
        // Get available liquidity
        uint256 availableLiquidity = IERC20(asset()).balanceOf(address(this));
        
        // If we don't have enough liquidity, try to withdraw from Aave
        if (repayAmount > availableLiquidity) {
            // Calculate how much we can safely withdraw (in asset terms)
            uint256 withdrawAmount = repayAmount - availableLiquidity;
            
            // Make sure we're not withdrawing more than our aToken balance
            uint256 aTokenBalance = IAToken(aToken).balanceOf(address(this));
            if (withdrawAmount > aTokenBalance) {
                withdrawAmount = aTokenBalance;
            }
            
            // Make sure we don't withdraw too much and go below MIN_HEALTH_FACTOR
            uint256 maxWithdraw = (totalCollateralETH * 1e18 - (totalDebtETH * 1e18) / MIN_HEALTH_FACTOR) * assetPrice / 1e18;
            if (withdrawAmount > maxWithdraw) {
                withdrawAmount = maxWithdraw;
            }
            
            // Withdraw from Aave if we have something to withdraw
            if (withdrawAmount > 0) {
                aavePool.withdraw(asset(), withdrawAmount, address(this));
                // Update available liquidity after withdrawal
                availableLiquidity = IERC20(asset()).balanceOf(address(this));
            }
        }
        
        // Make sure we don't try to repay more than we have
        if (repayAmount > availableLiquidity) {
            repayAmount = availableLiquidity;
        }
        
        // Approve Aave to spend the asset if we have something to repay
        if (repayAmount > 0) {
            IERC20(asset()).safeApprove(address(aavePool), 0); // Reset approval
            IERC20(asset()).safeApprove(address(aavePool), repayAmount);
            
            // Repay the debt (using rate mode 2 for variable rate)
            aavePool.repay(asset(), repayAmount, 2, user);
        }
        
        // Emit event with old and new health factors
        emit PositionAdjusted(currentHf, getHealthFactor(user));
    }
    
    // ============ Admin Functions ============

    /**
     * @notice Pause all state-changing operations
     * @dev Only callable by accounts with PAUSER_ROLE
     */
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @notice Unpause all state-changing operations
     * @dev Only callable by accounts with PAUSER_ROLE
     */
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }
    
    /**
     * @notice Grant Keeper role to an address
     * @param keeper Address to grant Keeper role to
     */
    function addKeeper(address keeper) external onlyOwner {
        grantRole(KEEPER_ROLE, keeper);
    }
    
    /**
     * @notice Revoke Keeper role from an address
     * @param keeper Address to revoke Keeper role from
     */
    function removeKeeper(address keeper) external onlyOwner {
        revokeRole(KEEPER_ROLE, keeper);
    }
    
    /**
     * @notice Recover ERC20 tokens sent by mistake
     * @param tokenAddress Address of the token to recover
     * @param to Address to send the tokens to
     * @param amount Amount to recover
     */
    function recoverERC20(
        address tokenAddress,
        address to,
        uint256 amount
    ) external onlyOwner {
        require(tokenAddress != address(asset()), "Cannot recover underlying asset");
        IERC20(tokenAddress).transfer(to, amount);
    }
}
